package io.urlscan.client.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable


@Serializable
enum class SavedSearchDatasource {
    @SerialName("hostnames") HOSTNAMES,
    @SerialName("scans") SCANS
}

@Serializable
enum class Tlp {
    @SerialName("red") RED,
    @SerialName("amber+strict") AMBER_STRICT,
    @SerialName("amber") AMBER,
    @SerialName("green") GREEN,
    @SerialName("clear") CLEAR
}

@Serializable
enum class TeamPermission {
    @SerialName("team:read") TEAM_READ,
    @SerialName("team:write") TEAM_WRITE
}


/**
 * Request wrapper for creating a saved search.
 */
@Serializable
data class SavedSearchRequestWrapper(
    val search: SavedSearchRequest
)

/**
 * Response wrapper for a single saved search.
 */
@Serializable
data class SavedSearchResponseWrapper(
    val search: SavedSearchResponse
)

/**
 * Response wrapper for listing saved searches.
 */
@Serializable
data class SavedSearchesListResponse(
    val searches: List<SavedSearchResponse>
)

// ============= REQUEST DTO =============

/**
 * Data Transfer Object for creating or updating a Saved Search.
 *
 * @property datasource Which data source this Saved Search operates on (hostnames or scans)
 * @property name User-facing short name for the search
 * @property query Search API query in Elasticsearch Query String syntax
 * @property description Short description of the search purpose
 * @property longDescription Longer, more detailed description
 * @property tlp Traffic Light Protocol indicator for urlscan Pro platform visibility
 * @property userTags User-supplied tags to apply to matching items
 *           Use prefixes: pro. (Pro users), public. (all users), private. (only you), team. (team members)
 * @property permissions Permissions controlling visibility: public:read, team:read, team:write
 */
@Serializable
data class SavedSearchRequest(
    val datasource: SavedSearchDatasource,
    val name: String,
    val query: String,
    val description: String? = null,
    val longDescription: String? = null,
    val tlp: Tlp? = null,
    @SerialName("usertags")
    val userTags: List<String>? = null,
    val permissions: List<String>? = null
) {
    init {
        require(name.isNotBlank()) { "Name cannot be blank" }
        require(query.isNotBlank()) { "Query cannot be blank" }
    }

    /**
     * Validate user tags have proper scope prefixes.
     */
    fun validateTags(): Boolean {
        val validPrefixes = setOf("pro.", "public.", "private.", "team.")
        return userTags?.all { tag ->
            validPrefixes.any { tag.startsWith(it) }
        } ?: true
    }
}

// ============= RESPONSE DTO =============

/**
 * Data Transfer Object representing a Saved Search response from the API.
 * This includes read-only fields populated by the server.
 *
 * @property id Unique ID of the Saved Search (read-only, generated by server)
 * @property datasource Which data source this Saved Search operates on
 * @property createdAt ISO8601 timestamp when the search was created (read-only)
 * @property name User-facing short name
 * @property description Short description
 * @property longDescription Long description
 * @property ownerDescription User-facing owner description (read-only)
 * @property query Search API query in Elasticsearch Query String syntax
 * @property tlp Traffic Light Protocol indicator
 * @property userTags Tags applied to matching items
 * @property permissions Access control permissions
 */
@Serializable
data class SavedSearchResponse(
    @SerialName("_id")
    val id: String,
    val datasource: SavedSearchDatasource,
    val createdAt: String,
    val name: String,
    val description: String? = null,
    val longDescription: String? = null,
    val ownerDescription: String? = null,
    val query: String,
    val tlp: Tlp? = null,
    @SerialName("usertags")
    val userTags: List<String>? = null,
    val permissions: List<String>? = null
) {

    /**
     * Check if this search is publicly readable.
     */
    val isPublic: Boolean
        get() = permissions?.contains("public:read") == true

    /**
     * Check if this search is team-accessible.
     */
    val isTeamAccessible: Boolean
        get() = permissions?.any { it.contains("team:") } == true

    /**
     * Check if this search is private.
     */
    val isPrivate: Boolean
        get() = permissions?.isEmpty() != false || permissions.all { !it.contains("public") && !it.contains("team") }
}