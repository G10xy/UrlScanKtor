package io.urlscan.client.model

import kotlinx.serialization.SerialName
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.JsonObject

/**
 * Enumeration of incident state values.
 */
@Serializable
enum class IncidentStateEnum {
    @SerialName("active") ACTIVE,
    @SerialName("closed") CLOSED
}

/**
 * Enumeration of incident visibility levels.
 */
@Serializable
enum class IncidentVisibility {
    @SerialName("unlisted") UNLISTED,
    @SerialName("private") PRIVATE
}

/**
 * Enumeration of incident types.
 */
@Serializable
enum class IncidentTypeEnum {
    @SerialName("url") URL,
    @SerialName("ip") IP,
    @SerialName("hostname") HOSTNAME
}

/**
 * Enumeration of scan interval modes for incidents.
 */
@Serializable
enum class ScanIntervalModeEnum {
    @SerialName("manual") MANUAL,
    @SerialName("automatic") AUTOMATIC
}

/**
 * Enumeration of incident source types.
 */
@Serializable
enum class SourceTypeEnum {
    @SerialName("manual") MANUAL,
    @SerialName("api") API,
    @SerialName("subscription") SUBSCRIPTION,
    @SerialName("fork") FORK,
    @SerialName("copy") COPY
}

/**
 * Data Transfer Object representing an incident.
 * Incidents track observables and automatically scan them for changes.
 *
 * @property id Unique ID of the incident (read-only, generated by server)
 * @property observable The hostname, domain, IP, or URL being tracked
 * @property visibility Incident visibility level: unlisted or private
 * @property channels Array of channel IDs where notifications will be sent
 * @property scanInterval Interval in seconds between triggering full website scans
 * @property scanIntervalMode Manual or automatic scan interval adjustment
 * @property watchedAttributes List of attributes to monitor for changes (detections, tls, dns, labels, page, meta, ip)
 * @property userAgents Browser User-Agents to use during scanning
 * @property userAgentsPerInterval How many userAgents to use per scanInterval
 * @property countries List of ISO-3166-1 country codes to scan from
 * @property countriesPerInterval How many countries to use per scan interval
 * @property stopDelaySuspended Seconds to automatically close incident after observable was suspended
 * @property stopDelayInactive Seconds to automatically close incident after observable became inactive
 * @property stopDelayMalicious Seconds to automatically close incident after observable became malicious
 * @property scanIntervalAfterSuspended How to change scan interval after observable was suspended
 * @property scanIntervalAfterMalicious How to change scan interval after observable became malicious
 * @property incidentProfile ID of the incident profile to use
 * @property type Incident type: url, ip, or hostname (read-only)
 * @property state Whether the incident is active or closed (read-only)
 * @property stateSize Size in bytes of incident states in database (read-only)
 * @property stateCount Number of stored incident states in database (read-only)
 * @property owner Incident owner (read-only)
 * @property sourceType How this incident was created: manual, api, subscription, fork, copy (read-only)
 * @property sourceId ID of the original item that created this incident (read-only)
 * @property createdAt ISO8601 timestamp when incident was created (read-only)
 * @property scannedAt ISO8601 timestamp of last scan (read-only)
 * @property expireAt ISO8601 timestamp when incident will be automatically closed (read-only)
 * @property labels Labels detected for this incident (read-only)
 */
@Serializable
data class Incident(
    @SerialName("_id")
    val id: String? = null,
    val observable: String,
    val visibility: IncidentVisibility,
    val channels: List<String>,
    val scanInterval: Int? = null,
    val scanIntervalMode: ScanIntervalModeEnum? = null,
    val watchedAttributes: List<String>? = null,
    val userAgents: List<String>? = null,
    val userAgentsPerInterval: Int? = null,
    val countries: List<String>? = null,
    val countriesPerInterval: Int? = null,
    val stopDelaySuspended: Int? = null,
    val stopDelayInactive: Int? = null,
    val stopDelayMalicious: Int? = null,
    val scanIntervalAfterSuspended: Int? = null,
    val scanIntervalAfterMalicious: Int? = null,
    val incidentProfile: String? = null,
    val type: IncidentTypeEnum? = null,
    val state: IncidentStateEnum? = null,
    val stateSize: Int? = null,
    val stateCount: Int? = null,
    val owner: String? = null,
    val sourceType: SourceTypeEnum? = null,
    val sourceId: String? = null,
    val createdAt: String? = null,
    val scannedAt: String? = null,
    val expireAt: String? = null,
    val labels: List<String>? = null
) {
    init {
        require(observable.isNotBlank()) { "Observable cannot be blank" }
        require(channels.isNotEmpty()) { "At least one channel must be specified" }
    }
}

/**
 * Data Transfer Object for incident creation/update requests.
 */
@Serializable
data class IncidentRequest(
    val incident: Incident
)

/**
 * Response wrapper for a single incident.
 */
@Serializable
data class IncidentResponse(
    val incident: Incident
)

/**
 * Data Transfer Object representing an incident state snapshot.
 * Captures the state of an incident at a specific point in time.
 *
 * @property id Unique ID of the incident state interval
 * @property incident ID of the parent incident
 * @property state Current state snapshot (contains various metrics and observations)
 * @property timeStart Start time of the state interval
 * @property timeEnd End time of the state interval
 */
@Serializable
data class IncidentState(
    @SerialName("_id")
    val id: String,
    val incident: String,
    val state: JsonObject? = null,
    val timeStart: String? = null,
    val timeEnd: String? = null
)

/**
 * Response wrapper for incident states list.
 */
@Serializable
internal data class IncidentStatesResponse(
    val incidentstates: List<IncidentState>
)

/**
 * Response wrapper for watchable attributes.
 */
@Serializable
internal data class WatchableAttributesResponse(
    val attributes: List<String>
)